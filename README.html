<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="linked-adm-in">Linked-adm-In</h1>
<p>Final project for the Advanced Data Mangaement course</p>
<h3 id="assignment-steps">Assignment Steps:</h3>
<ul>
<li><input type="checkbox" id="checkbox0" checked="true"><label for="checkbox0">1. Propose a domain you are interested in and a relevant application for it (e.g.,e-commerce domain, shopping cart and session data management application). Take inspirations from datasets available online (e.g., on https://www.kaggle.com).</label></li>
<li><input type="checkbox" id="checkbox1" checked="true"><label for="checkbox1">2. Provide details about the nature of the proposed application (e.g., the application is read/write intensive, requires batch processing, ...), according to what discussed in the course and corresponding system requirements (e.g., eventual/strong consistency needed, high availability needed).</label></li>
<li><input type="checkbox" id="checkbox2" checked="true"><label for="checkbox2">3. Design a conceptual schema for the identified domain. The schema should include at least three associations.</label></li>
<li><input type="checkbox" id="checkbox3" checked="true"><label for="checkbox3">4. Identify a workload, i.e., a set of relevant and frequent operations, related to the chosen application. The workload should contain at least 5 structurally different operations. Describe each workload operation in natural language.</label></li>
<li><input type="checkbox" id="checkbox4" checked="true"><label for="checkbox4">5. Use the aggregate-oriented design methodology (STEP 1-2-3) to design a set of aggregates for the domain and the workload at hand.</label></li>
<li><input type="checkbox" id="checkbox5" checked="true"><label for="checkbox5">6. Design in MongoDB:</label>
<ul>
<li><input type="checkbox" id="checkbox6" checked="true"><label for="checkbox6">a. Design a schema for MongoDB (including partition keys and indexes), starting from (step 5), using the approaches/methodologies proposed in the course.</label></li>
<li><input type="checkbox" id="checkbox7" checked="true"><label for="checkbox7">b. Specify each operation of the workload in the language supported by MongoDB</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox8" checked="true"><label for="checkbox8">7. Design in Cassandra:</label>
<ul>
<li><input type="checkbox" id="checkbox9" checked="true"><label for="checkbox9">a. Design a schema for Cassandra  (including partition keys and indexes), starting from (step 5), using the approaches/methodologies proposed in the course.</label></li>
<li><input type="checkbox" id="checkbox10" checked="true"><label for="checkbox10">b. Specify in CQL each operation of the workload.</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox11" checked="true"><label for="checkbox11">8. Design in Neo4J:</label>
<ul>
<li><input type="checkbox" id="checkbox12" checked="true"><label for="checkbox12">a. Design a schema for Neo4j, using the approaches/methodologies proposed in the course.</label></li>
<li><input type="checkbox" id="checkbox13" checked="true"><label for="checkbox13">b. Specify in Neo4j each operation of the workload.</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox14" checked="true"><label for="checkbox14">9. Discuss which, among the three systems, is the most suitable to be used as  back-end for your application. Motivate your choice, taking into account the features of your application (step 2) and the identified workload (step 4). Let S be the selected system.</label></li>
<li><input type="checkbox" id="checkbox15"><label for="checkbox15">10. Provide details about the system configuration needed in system S  for storing/processing your data according to the chosen application.</label></li>
<li><input type="checkbox" id="checkbox16"><label for="checkbox16">11. Create the logical schema in system S.</label></li>
<li><input type="checkbox" id="checkbox17"><label for="checkbox17">12. Create an instance of your schema in the selected system, according to the logical schema just created. To this aim:</label>
<ul>
<li><input type="checkbox" id="checkbox18"><label for="checkbox18">a. You can use either an already available dataset or a synthetic one but we encourage the first option (it might be difficult to synthetically generate a relevant dataset for your reference application). The dataset should have a reasonable size (few Mb).</label></li>
<li><input type="checkbox" id="checkbox19"><label for="checkbox19">b. Notice that selected datasets might need to be transformed in order to be used by your application. For dataset transformation, you can rely on either data transformation tools, such as Tableaux Prep (www.tableau.com), Apache Superset (superset.apache.org) Trifacta ( www.trifacta.com ), or other ETL tools such as Talend ( www.talend.com ), or scripts in your favorite language.</label></li>
<li><input type="checkbox" id="checkbox20"><label for="checkbox20">c. For importing datasets in the chosen system, you should refer to the available documentation for the system you have selected (e.g. https://www.datastax.com/dev/blog/simple-data-importing-and-exporting-with-cassandra for Cassandra and https://neo4j.com/developer/guide-importing-data-and-etl/perneo4J for Neo4J).</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox21"><label for="checkbox21">13. Implement the workload in system S.</label></li>
<li><input type="checkbox" id="checkbox22"><label for="checkbox22">14. Model in RDFS / OWL the main classes and the main properties corresponding to the entities and associations in the conceptual schema (step 3). In addition:</label>
<ul>
<li><input type="checkbox" id="checkbox23"><label for="checkbox23">a. For each property, specify the corresponding domain and range.</label></li>
<li><input type="checkbox" id="checkbox24"><label for="checkbox24">b. Express which classes are equivalent and which ones are disjoint.</label></li>
<li><input type="checkbox" id="checkbox25"><label for="checkbox25">c. Specify (or add) at least an inverse property.</label></li>
<li><input type="checkbox" id="checkbox26"><label for="checkbox26">d. For all the modeled properties, specify whether they are functional (or inverse functional).</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox27"><label for="checkbox27">15. Model in RDF some instances  to populate your schema. In addition:</label>
<ul>
<li><input type="checkbox" id="checkbox28"><label for="checkbox28">a. Relate instances to the corresponding class or property.</label></li>
<li><input type="checkbox" id="checkbox29"><label for="checkbox29">b. Clarify which individuals are identical and which ones are different.</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox30"><label for="checkbox30">16. Specify in SPARQL at least 3 queries to be executed over the defined RDF dataset. The requests should:</label>
<ul>
<li><input type="checkbox" id="checkbox31"><label for="checkbox31">a. be structurally different (i.e., each of them should contain different constructs)</label></li>
<li><input type="checkbox" id="checkbox32"><label for="checkbox32">b. include at least one CONSTRUCT query</label></li>
<li><input type="checkbox" id="checkbox33"><label for="checkbox33">c. refer as much as possible to the requests included in the workload specified in PART II.</label></li>
</ul>
</li>
<li><input type="checkbox" id="checkbox34"><label for="checkbox34">17. Check the correctness of the proposed RDF dataset, extended with RDFS /OWL constraints, and of the proposed SPARQL queries using RDF playground (http://rdfplayground.dcc.uchile.cl/) or any other RDF data store at your choice.</label></li>
</ul>
<h3 id="dataset-link">dataset link</h3>
<p>https://www.kaggle.com/datasets/arshkon/linkedin-job-postings</p>
<h3 id="project-description-link">project description link</h3>
<p>https://2024.aulaweb.unige.it/mod/page/view.php?id=56196</p>
<h1 id="nature-of-the-proposed-application">Nature of the Proposed Application</h1>
<h2 id="1-2-the-proposed-application-is-a-job-and-industry-relationship-analysis-tool-its-features-and-requirements-include">(1-2) The proposed application is a job and industry relationship analysis tool. Its features and requirements include:</h2>
<pre><code>Read/Write Intensity
The application is predominantly read-intensive, as it emphasizes retrieving data; such as querying the skills required for a job, the benefits offered, or the industries associated with a company.
Write operations occur moderately, primarily when new jobs, companies, skills, or benefits are added to the system. These updates may include inserting related attributes like market values, skill scores, or job expiration dates.

Batch Processing
No Batch processing, beacause the only big import can be required during initialization: no large updates to the dataset will occur. 
The only updates might be occasionaly integrating new company records or updated job postings.

Consistency and Availability
Eventual consistency is sufficient for updates to non-critical attributes, such as adding new benefits or updating a company’s market value. These changes are not immediately critical for most queries.
For core operations (e.g., adding new jobs or companies), ensuring consistency is more critical, as incomplete or incorrect relationships (e.g. a job missing its associated company) could affect query accuracy.
However, having high availability clearly is the most important goal to reach, particularly for supporting real-time data retrieval and queries.

Performance
The system should be optimized for retrieving and filtering data (also across entities), such as:
Searching for jobs based on attributes like type, location, or expiration date.
Filtering companies by criteria like market value, location, or associated industries.
</code></pre>
<p>(3) Conceptual Schema</p>
<p>The following conceptual schema captures key entities and their relationships:</p>
<pre><code>Nodes:
    Job(Title, Expire date, Type): Represents a job posting (for now has a title attribute)
    Company(Name, Country, City, ZipCode, MarketValue): Represents a company (for now has a name attribute)
    IndustryDomain(Name): Represents an industry domain 
    Skill(Name, Level, Score): Represents skills associated with a job
    Benefit(Type (PK), Economical Value): Represents benefits offered for a job

Relationships:
    BELONGS_TO: Links a job to an company (1-N: with an attribute &quot;salary&quot; of the association)
    --&gt; the key of Job will be the composite of title and the foreign key of company
    REQUIRES: Links a job to the skills it demands (N-N)
    OFFERS: Links a job to the benefits it provides (N-N)
    OPERATES_IN: Links a company to the industries it operates in (1-N)
</code></pre>
<p><img src="https://github.com/user-attachments/assets/bb3e515b-c972-4ad3-827a-d7471e4cd96a" alt="Er1"></p>
<p>(4) Queries:</p>
<pre><code>Query 1: Find all jobs that are Full-time and expiring within the next 30 days.
Q1(Job, [Job(type)_!, Job(expire_date)_!], [Job_!])

Query 2: List the name of companies in New York with a market value greater than $1,000,000.
Q2(Company, [Company(city)_!, Company(mv)_!], [Company(name)_!])

Query 3: List name and market value of companies operating in Russia and associated with jobs that expire in more than 60 days.
Q3(Job, [Company(country)_L, Job(expire_date)_!], [Company(name, mv)_L])

Query 4: List type of jobs associated with companies operating in the Technology domain
Q4(IndustryDomain, [IndustryDomain(Name)_!], [Job(type)_LO])

Query 5: List type jobs associated with italian companies operating in the Technology domain
Q5(Company, [IndustryDomain(Name)_O, Company(country)_!], [Job(type)_L])

Query 6: Retrieve name of skills required for jobs offering benefits of type 401(k) and having a score above 70.
Q6(Skill, [Skill(score)_!, Benefit(type)_OR], [Skill(name)_!])

Query 7: Find the title of all jobs of type Internship that require skills with a level of &quot;Beginner&quot; and are associated with companies in Hamburg
Q7(Job, [Job(type)_!, Skill(level)_R, Company(city)_L], [Job(title)_!])
</code></pre>
<p><img src="https://github.com/user-attachments/assets/4ee6f063-1eb2-4135-add3-5e7ee2a707f9" alt="ER2"></p>
<h2 id="5-aggregates">(5) Aggregates</h2>
<h3 id="joboffer----q1-q3-q7">JobOffer: <!-- Q1, Q3, Q7 --></h3>
<p>{
<ins>title, companyName</ins>, expire_date, type, country, city, marketValue,
requires: [{skill: {level}}]
}</p>
<h3 id="company----q2-q5">Company: <!-- Q2, Q5 --></h3>
<p>{
<ins>name</ins>, marketValue, country, city,
job_offers: [{job: {type}}],
industryName <!-- simple attribute because it comes from a (1,1) association -->
}</p>
<h3 id="industrydomain----q4">IndustryDomain: <!-- Q4 --></h3>
<p>{
<ins>name</ins>,
operated: [{ company: [{ job: {type} }] }] <!-- dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs-->
}</p>
<h3 id="skill----q6">Skill: <!-- Q6 --></h3>
<p>{
<ins>name</ins>,score,
provides: [{benefit: {type}}] <!-- double n-n relationship unpacked into a single list: we're only interested in benefits that skills provides, regardless of the jobs -->
}</p>
<h3 id="note-inspect-md-to-see-comments">Note: inspect .md to see comments</h3>
<h2 id="6-design-in-mongodb">(6) Design in MongoDB</h2>
<h3 id="queries-associated-with-skill-q6">Queries associated with Skill: Q6</h3>
<p>Selection attributes for Q6: {score, type} <!-- benefit type --></p>
<p>Skill: <!-- Q6 -->
{
<ins>name</ins>,score,
provides: [{benefit: {type}}] <!-- double n-n relationship unpacked into a single list: we're only interested in benefits that skills provides, regardless of the jobs -->
}</p>
<ul>
<li>A non-unique index on the partition key with Partition key = {score, type}</li>
</ul>
<pre class="hljs"><code><div>      db.skills.createIndex({ score: 1, &quot;provides.benefit.type&quot;: 1 });
</div></code></pre>
<ul>
<li>A compound-unique index which contains the full shard key as a prefix of the index = {score, type, name}</li>
</ul>
<pre class="hljs"><code><div>db.skills.createIndex(
          { score: 1, &quot;provides.benefit.type&quot;: 1, name: 1 },
          { unique: true }
  );
</div></code></pre>
<ul>
<li>Shard collection</li>
</ul>
<pre class="hljs"><code><div>db.adminCommand({
  shardCollection: &quot;db.skill&quot;,
  key: { score: 1, &quot;provides.benefit.type&quot;: 1 }
});
</div></code></pre>
<ul>
<li>Q6:</li>
</ul>
<pre class="hljs"><code><div>  db.skills.find({score: {$gt: 70}, &quot;provides.benefit.type&quot;: &quot;401(k)&quot;}, {name: 1, _id: 0});
</div></code></pre>
<h3 id="queries-associated-with-industrydomain-q4">Queries associated with IndustryDomain: Q4</h3>
<p>Selection attributes for Q4: {name} <!-- IndustryDomain name --></p>
<h3 id="industrydomain----q4">IndustryDomain: <!-- Q4 --></h3>
<p>{
<ins>name</ins>,
operated: [{ company: [{ job: {type} }] }] <!-- dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs-->
}</p>
<ul>
<li>A unique index on the partition key, which is also the aggregate key = {name}</li>
</ul>
<pre class="hljs"><code><div>  db.industryDomains.createIndex({ name: 1 }, { unique: true });
</div></code></pre>
<ul>
<li>Shard collection</li>
</ul>
<pre class="hljs"><code><div>db.adminCommand({
  shardCollection: &quot;db.industryDomain&quot;,
  key: { name: 1 }
});
</div></code></pre>
<ul>
<li>Q4:</li>
</ul>
<pre class="hljs"><code><div>  db.industryDomains.aggregate([
  {
    $match: {
      name: &quot;Technology&quot;
    }
  },
  {
    $unwind: &quot;$operated&quot;
  },
  {
    $unwind: &quot;$operated.company&quot;
  },
  {
    $unwind: &quot;$operated.company.job&quot;
  },
  {
    $project: {
      _id: 0,
      jobType: &quot;$operated.company.job.type&quot;
    }
  },
  {
    $group: {
      _id: null,
      jobTypes: { $addToSet: &quot;$jobType&quot; }
    }
  },
  {
    $project: {
      _id: 0,
      jobTypes: 1
    }
  }
]);
</div></code></pre>
<h3 id="queries-associated-with-company-q2-q5">Queries associated with Company: Q2, Q5</h3>
<p>Selection attributes for Q2: {city, mv}</p>
<p>Selection attributes for Q5: {country, industryName} <!-- IndustryDomain name --></p>
<h3 id="company----q2-q5">Company: <!-- Q2, Q5 --></h3>
<p>{
<ins>name</ins>, marketValue, country, city,
job_offers: [{job: {type}}],
industryName <!-- simple attribute because it comes from a (1,1) association -->
}</p>
<ul>
<li>Given that the intersection between selection attributes in Q2 and Q5 is empty: instead of having a single non-unique index on {city, mv, country, industryName} we choose to separetely support both queries by creating two separate non-unique indexes onto them:</li>
</ul>
<pre class="hljs"><code><div>    db.companies.createIndex({ city: 1, mv: 1 });
    db.companies.createIndex({ country: 1, industryName: 1 });
</div></code></pre>
<p>Then, after having thought about both queries, we create a mixed non-unique index for sharding and to then support the uniqueness of name with a compound index:</p>
<pre class="hljs"><code><div>    db.companies.createIndex({ city: 1, country: 1 });
</div></code></pre>
<ul>
<li>A compound-unique index which contains the full shard key as a prefix of the index = {score, type, name}</li>
</ul>
<pre class="hljs"><code><div>    db.companies.createIndex(
      { city: 1, country: 1, name: 1 },
      { unique: true }
    );
</div></code></pre>
<ul>
<li>Shard collection</li>
</ul>
<pre class="hljs"><code><div>    db.adminCommand({
      shardCollection: &quot;db.Company&quot;,
      key: { city: 1, country: 1 }
    });
</div></code></pre>
<ul>
<li>Q2:</li>
</ul>
<pre class="hljs"><code><div>  db.companies.find({ city: &quot;New York&quot;, mv: { $gt: 1000000 } }, { name: 1, _id: 0 });
</div></code></pre>
<ul>
<li>Q5:</li>
</ul>
<pre class="hljs"><code><div>  db.companies.aggregate([
  {
    $match: {
      country: &quot;Italy&quot;,
      industryName: &quot;Technology&quot;
    }
  },
  {
    $unwind: &quot;$job_offers&quot;
  },
  {
    $project: {
      _id: 0,
      jobType: &quot;$job_offers.job.type&quot;
    }
  },
  {
    $group: {
      _id: null,
      jobTypes: { $addToSet: &quot;$jobType&quot; }
    }
  },
  {
    $project: {
      _id: 0, // the grouping creates again an _id :(
      jobTypes: 1
    }
  }
]);
</div></code></pre>
<h3 id="queries-associated-with-joboffer-q1-q3-q7">Queries associated with JobOffer: Q1, Q3, Q7</h3>
<p>Selection attributes for Q1: {type, expire_date}</p>
<p>Selection attributes for Q3: {country, expire_date}</p>
<p>Selection attributes for Q7: {type, city, level}</p>
<h3 id="joboffer----q1-q3-q7">JobOffer: <!-- Q1, Q3, Q7 --></h3>
<p>{
<ins>title, companyName</ins>, expire_date, type, country, city, marketValue,
requires: [{skill: {level}}]
}</p>
<ul>
<li>We observe that type appears in both Q1 and Q7 while expire_date in both Q1 and Q3: so we have an empty intersection but a partial overlap that can be leveraged to support multiple queries efficiently.
Consequently, we can think about:
<ul>
<li>A composite index on {type, expire_date, city, level}: mongo uses a prefix for filtering so this will support both Q1 and Q7</li>
</ul>
<pre class="hljs"><code><div>db.jobOffers.createIndex({ type: 1, expire_date: 1, city: 1, level: 1 });
</div></code></pre>
<ul>
<li>We can follow a similar approach to combine Q1 and Q3 obtaining an index on {expire_date, type, country}</li>
</ul>
<pre class="hljs"><code><div>db.jobOffers.createIndex({ expire_date: 1, type: 1, country: 1 });
</div></code></pre>
<ul>
<li>Then, we think about having a compound unique index to enforce key constraint on the aggregate key {title, companyName}: given that type and expire_date are in partial overlap between queries we select them as a shard key. Here the unique index:</li>
</ul>
<pre class="hljs"><code><div>db.jobOffers.createIndex(
  { type: 1, expire_date: 1, title: 1, companyName: 1 },
  { unique: true }
);
</div></code></pre>
</li>
<li>Shard collection</li>
</ul>
<pre class="hljs"><code><div>db.adminCommand({
  shardCollection: &quot;db.JobOffer&quot;,
  key: { type: 1, expire_date: 1 }
});
</div></code></pre>
<ul>
<li>Q1:</li>
</ul>
<pre class="hljs"><code><div>  db.jobOffers.find(
  {
    type: &quot;Full-time&quot;,
    expire_date: { $lte: new Date(new Date().setDate(new Date().getDate() + 30)) }
  },
  {
    _id: 0
  }
);
</div></code></pre>
<ul>
<li>Q3:</li>
</ul>
<pre class="hljs"><code><div>  db.jobOffers.aggregate([
  {
    $match: {
      country: &quot;Russia&quot;,
      expire_date: { $gt: new Date(new Date().setDate(new Date().getDate() + 60)) }
    }
  },
  {
    $project: {
      _id: 0,
      companyName: 1,
      marketValue: 1
    }
  },
  {
    $group: {
      _id: &quot;$companyName&quot;, // Group by company name
      marketValue: { $first: &quot;$marketValue&quot; } // Collect the first market value (one value per company!)
    }
  }
]);
</div></code></pre>
<p>Side note on this Q3: $first is used in MongoDB grouping to select the first encountered value of a field (e.g., marketValue) that is not part of the grouping key, providing a simple and efficient way to handle such fields without requiring computation.</p>
<ul>
<li>Q7:</li>
</ul>
<pre class="hljs"><code><div>  db.jobOffers.find(
  {
    type: &quot;Internship&quot;,
    city: &quot;Hamburg&quot;,
    &quot;requires.skill.level&quot;: &quot;Beginner&quot;
  },
  {
    _id: 0,
    title: 1
  }
);
</div></code></pre>
<h2 id="7-design-in-cassandra">(7) Design in Cassandra</h2>
<h3 id="queries-associated-with-skill-q6">Queries associated with Skill: Q6</h3>
<p>Selection attributes for Q6: {score, type} <!-- benefit type --></p>
<p>Skill: <!-- Q6 -->
{
<ins>name</ins>,score,
provides: [{benefit: {type}}] <!-- double n-n relationship unpacked into a single list: we're only interested in benefits that skills provides, regardless of the jobs -->
}</p>
<ul>
<li>Given that we have only one query we can safely select {score, type} as partition key, while for the primary key we have to add the aggregate key &quot;name&quot; in order to have the aggregate identifier. We obtain:
<ul>
<li>Partition key = {score, type}</li>
<li>Primary key = {score, key, name} with name as clustering column</li>
</ul>
</li>
<li>Here are the CREATE commands in Cassandra:</li>
</ul>
<pre class="hljs"><code><div>  CREATE TYPE benefit_t (
    type text
);

CREATE TABLE Skills (
    name text,
    score int,
    type text,
    provides set&lt;frozen&lt;benefit_t&gt;&gt;,
    PRIMARY KEY ((score, type), name)
);

</div></code></pre>
<p>In summary:</p>
<p>TYPE benefit_t defines the structure for benefits for semantic reasons</p>
<p>((score, type)) as partition key ensures data is grouped by score and type</p>
<p>name as clustering column differentiates entries within each (score, type) partition</p>
<p>provides represents the benefits associated with a skill as a set of the previously created frozen benefit_t</p>
<ul>
<li>Q6:</li>
</ul>
<pre class="hljs"><code><div>SELECT name
FROM Skills
WHERE score &gt; 70 AND type = '401(k)';
</div></code></pre>
<h3 id="queries-associated-with-industrydomain-q4">Queries associated with IndustryDomain: Q4</h3>
<p>Selection attributes for Q4: {name} <!-- IndustryDomain name --></p>
<h3 id="industrydomain----q4">IndustryDomain: <!-- Q4 --></h3>
<p>{
<ins>name</ins>,
operated: [{ company: [{ job: {type} }] }] <!-- dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs-->
}</p>
<ul>
<li>Given that name is both the only selection attribute and the aggregate key we only have to select it as Partition Key!
<ul>
<li>Partition key = {name}</li>
</ul>
</li>
<li>Here are the CREATE commands in Cassandra:</li>
</ul>
<pre class="hljs"><code><div>CREATE TYPE job_t (
    type text
);

CREATE TYPE company_t (
    job list&lt;frozen&lt;job_t&gt;&gt;
);

CREATE TABLE IndustryDomain (
    name text PRIMARY KEY,
    operated list&lt;frozen&lt;company_t&gt;&gt;
);
</div></code></pre>
<p>In summary:</p>
<p>TYPE job_t represents the type of jobs associated with a company</p>
<p>TYPE company_t represents a company, with its associated job types encapsulated as a list of job_t</p>
<p>IndustryDomain uses name as the Partition Key &amp; the operated field stores the hierarchical relationship of companies and jobs.</p>
<ul>
<li>Q4:</li>
</ul>
<pre class="hljs"><code><div>SELECT operated 
FROM IndustryDomain 
WHERE name = 'Technology';
</div></code></pre>
<h3 id="queries-associated-with-company-q2-q5">Queries associated with Company: Q2, Q5</h3>
<p>Selection attributes for Q2: {city, mv}</p>
<p>Selection attributes for Q5: {country, industryName} <!-- IndustryDomain name --></p>
<h3 id="company----q2-q5">Company: <!-- Q2, Q5 --></h3>
<p>{
<ins>name</ins>, marketValue, country, city,
job_offers: [{job: {type}}],
industryName <!-- simple attribute because it comes from a (1,1) association -->
}</p>
<ul>
<li>Unlikely the intersection between Q2 and Q5 selection attributes is empty: The only solution is to split the aggregate into two column-families!</li>
</ul>
<pre class="hljs"><code><div>CREATE TYPE job_t (
    type text
);

CREATE TABLE Company2 (
    city text,
    marketValue double,
    name text,
    country text,
    job_offers list&lt;frozen&lt;job_t&gt;&gt;,
    industryName text,
    PRIMARY KEY ((city, marketValue), name)
);

CREATE TABLE Company5 (
    city text,
    marketValue double,
    name text,
    country text,
    job_offers list&lt;frozen&lt;job_t&gt;&gt;,
    industryName text,
    PRIMARY KEY ((country, industryName), name)
);
</div></code></pre>
<p>Company2 will be used for executing Q2 and Company5 for executing Q5.</p>
<p>A further analysis can lead us to optimize, for example, C5 table by removing unnecessary fields (we still have C2 for other fields if required, so no needs to include extra field on a table that should be mainly tailored to allow the execution of query 5.</p>
<pre class="hljs"><code><div>CREATE TABLE Company5 (
    country TEXT,
    industryName TEXT,
    name TEXT,
    job_offers LIST&lt;FROZEN&lt;job_t&gt;&gt;,
    PRIMARY KEY ((country, industryName), name)
);
</div></code></pre>
<ul>
<li>Q2:</li>
</ul>
<pre class="hljs"><code><div>SELECT name 
FROM Company2 
WHERE city = 'New York' AND marketValue &gt; 1000000.0;
</div></code></pre>
<ul>
<li>Q5:</li>
</ul>
<pre class="hljs"><code><div>SELECT job_offers 
FROM Company5 
WHERE country = 'Italy' AND industryName = 'Technology';
</div></code></pre>
<h3 id="queries-associated-with-joboffer-q1-q3-q7">Queries associated with JobOffer: Q1, Q3, Q7</h3>
<p>Selection attributes for Q1: {type, expire_date}</p>
<p>Selection attributes for Q3: {country, expire_date}</p>
<p>Selection attributes for Q7: {type, city, level}</p>
<h3 id="joboffer----q1-q3-q7">JobOffer: <!-- Q1, Q3, Q7 --></h3>
<p>{
<ins>title, companyName</ins>, expire_date, type, country, city, marketValue,
requires: [{skill: {level}}]
}</p>
<ul>
<li>Given our partial overlap we are able to carefully design this solution. Here are two candidate pairings:
<ul>
<li>
<p>Option 1: Combine Q1 and Q3
Shared attribute: expire_date.
Partitioning by expire_date allows efficient filtering for both queries.</p>
</li>
<li>
<p>Option 2: Combine Q1 and Q7
Shared attribute: type.
Partitioning by type allows efficient filtering for both queries.</p>
</li>
</ul>
</li>
</ul>
<p>--&gt; We decide to opt for mixing Q1 and Q3 because expire_date is time-based and therefore with high selection factor (we have less types then expire_dates so makes sense to group the latter).</p>
<pre class="hljs"><code><div>CREATE TYPE skill_t (
    level text
);

CREATE TABLE Job1_3 (
    expire_date DATE,
    type text,
    country text,
    title text,
    companyName text,
    city text,
    marketValue double,
    requires list&lt;frozen&lt;skill_t&gt;&gt;,
    PRIMARY KEY (expire_date, type, country, title, companyName)
);

CREATE TABLE Job7 (
    expire_date DATE,
    type text,
    country text,
    title text,
    companyName text,
    city text,
    marketValue double,
    requires list&lt;frozen&lt;skill_t&gt;&gt;,
    PRIMARY KEY ((type, city, level), title, companyName)
);
</div></code></pre>
<p>A further analysis can lead us to optimize, for example, Job7 table by removing unnecessary fields (we still have Job1_3 for other fields if required, so no needs to include extra field on a table that should be mainly tailored to allow the execution of query 7.</p>
<pre class="hljs"><code><div>CREATE TABLE Job7 (
    type text,
    city text,
    level text,
    title text,
    companyName text,
    PRIMARY KEY ((type, city, level), title, companyName)
);
</div></code></pre>
<ul>
<li>Q1:</li>
</ul>
<pre class="hljs"><code><div>SELECT * 
FROM Job1_3 
WHERE type = 'Full-time' AND expire_date &lt;= toDate(now()) + 30;
</div></code></pre>
<ul>
<li>Q3:</li>
</ul>
<pre class="hljs"><code><div>SELECT companyName, marketValue 
FROM Job1_3 
WHERE country = 'Russia' AND expire_date &gt; toDate(now()) + 60;
</div></code></pre>
<ul>
<li>Q7:</li>
</ul>
<pre class="hljs"><code><div>SELECT title 
FROM Job7 
WHERE type = 'Internship' 
  AND city = 'Hamburg' 
  AND level = 'Beginner';
</div></code></pre>
<h2 id="8-design-in-neo4j">(8) Design in Neo4J</h2>
<p><img src="https://github.com/user-attachments/assets/3680f296-22f0-4a47-8fa3-324540351316" alt="graph"></p>
<p>Query workload in Neo4J (from 1 to 7):</p>
<pre class="hljs"><code><div>MATCH (j:Job)
WHERE j.type = 'Full-time' AND j.exp_date &lt;= date() + duration({days: 30})
RETURN j

MATCH (c:Company)
WHERE c.city = 'New York' AND c.mv &gt; 1000000
RETURN c.name

MATCH (c:Company {country = 'Russia'})-[:LISTS]-&gt;(j:Job)
WHERE j.exp_date &gt; date() + duration({days: 60})
RETURN c.name, c.mv

MATCH (id:IndustryDomain)&lt;-[:OPERATES_IN]-(c:Company)-[:LISTS]-&gt;(j:Job)
WHERE id.name = 'Technology'
RETURN j.type

MATCH (id:IndustryDomain)&lt;-[:OPERATES_IN]-(c:Company {country: 'Italy'})-[:LISTS]-&gt;(j:Job)
WHERE id.name = 'Technology'
RETURN j.type

MATCH (s:Skill)&lt;-[:REQUIRES]-(j:Job)-[:OFFERS]-&gt;(b:Benefit)
WHERE s.score &gt; 70 AND b.type = '401(k)'
RETURN s.name

MATCH (j:Job {type: 'Internship'})-[:REQUIRES]-&gt;(s:Skill {level: 'Beginner'}), 
      (j)&lt;-[:LISTS]-(c:Company {city: 'Hamburg'})
RETURN j.title
</div></code></pre>
<p>Note: when it comes on choosing whether to put &quot;WHERE&quot; or leveraging &quot;{...}&quot; the decision relies on both flexibility and clarity. For complex conditions we chose WHERE, while for simple conditions of the &quot;starting&quot; node in the path we opted for a direct {...} inside the MATCH parenthesis.</p>
<h2 id="9-system-s-choice">(9) System S choice:</h2>
<p>Given that our application is:
- predominanty read-intensive
- with high avaibility constraints
- some consistency constraints
- no need of batch-processing
- highly relational queries</p>
<ul>
<li>We select <strong>Neo4J</strong> as system S for suitable backend for our application. This is driven by the following reasonings:
<ul>
<li>The application is centered on relationships and traversals (e.g linking jobs to companies, industries, skills, and benefits), as graph databases benefits provide.</li>
<li>Cypher queries easily handles our workload, as opposed to MongoDB.</li>
<li>Our modelled graph is able to direclty reflect the conceptual schema, as opposed to Cassandra.</li>
<li>Perfectly suitable for high avaibility and read-intensive data</li>
<li>CA tailored</li>
</ul>
</li>
</ul>
<p>The only weakness is with respect to scalability of writes, but as we said the percentage of write operations is hugely lower than the write one (also, write operations are limited to little additions of new jobs when occasionaly they pop-up).</p>
<ul>
<li>
<p>We discarded MongoDB due to:</p>
<ul>
<li>unintuitive relationships handling</li>
<li>not so optimized aggregation pipelines on most of the queries (due to them being highly relational)</li>
</ul>
</li>
<li>
<p>We discarded Cassandra due to:</p>
<ul>
<li>Multiple denormalized tables, originated to a schema design that has to be tailored to specific queries (that present multiple disjoint scenarios with respect to selection attributes)</li>
<li>No query flexibility for future workload changes, highly probable in this dynamic world of jobs.</li>
</ul>
</li>
</ul>
<h2 id="10-neo4j-configuration-details">(10) Neo4J: Configuration details</h2>
<p>We need:</p>
<ul>
<li>Neo4J Aura instance to implement our system</li>
<li>Query performance optimization by indexing when feasible (see (13))</li>
<li>High RAM size for data traversal (Neo4J instance will be enough for our dataset's size)</li>
</ul>
<p>If really implementing a scalable business solution, we would also need a clustering mechanisms to ensure high avaibility and causal consistency (let's remember that Neo4J is a CA system and it relies on causal consistency). Let's make an example configuration:</p>
<pre class="hljs"><code><div>causal_clustering.enabled=true
causal_clustering.minimum_core_cluster_size_at_runtime=3
</div></code></pre>
<p>Then, when deploying Neo4j for a read-intensive workload with high availability and potential fault tolerance, the &quot;R + W &gt; N&quot; rule becomes crucial: R (# of replicas that respond to read requests) and W (# of core nodes required for a successful write) must exceed the total number of N (core nodes in the cluster). Keeping in mind that in Neo4J each write operation is replicated across core nodes to keep consistency we have to carefully choose values for N, W and N.</p>
<ul>
<li>As said before N = 3 (so with a fault tolerance of 1 node failure and therefore a minimum quorum of 2 nodes)</li>
<li>We can set W = 2 (at minimum 2 nodes have to commit a write for it being successfull)<pre class="hljs"><code><div>dbms.cluster.minimum_core_write_quorum=2
</div></code></pre>
</li>
<li>We can set R = 2 (at least 2 replicas have to respond to that request)<pre class="hljs"><code><div>causal_clustering.read_replica_count=2
</div></code></pre>
</li>
<li>R + W in this scenario = 4, that indeed is higher then N = 3!</li>
</ul>
<p>Then, to scale-up in our read-intensive application, we would need to increase the read replicas.</p>
<p>For example, the following might be a feasible <em>job board</em> scenario, in which the course concepts could be highly applied:</p>
<p>To scale up in our read-intensive application we would primarily focus on increasing the number of read replicas, which in Neo4j are dedicated nodes that serve only read queries, offloading the weight from the core nodes and allowing the system to handle significantly higher query volumes.</p>
<p>For example, our job-board scenario mentioned above, the system must handle a high volume of user queries. Since the majority of these operations are read-only, the read replicas can efficiently handle these requests without impacting the performance of the core nodes.</p>
<p>So, in our previous example, as the number of users grows, we can step-by-step increase the number of read replicas depending on the query load; and since read replicas only need to synchronize with the core nodes periodically they can scale horizontally (and also being geographically replicated) without requiring changes to the core cluster configuration!</p>
<h2 id="11-neo4j-schema-details">(11) Neo4J: Schema details</h2>
<p>Given Neo4J schema-less nature we don't have to provide any schema details (like in Cassandra for example, where we would have needed some table specifications). Here we just need to dynamically create nodes and their relationships, as we'll do in the next step.
Nevertheless, here follows a basic <strong>example</strong> on how the nodes should appear in our database insertion:</p>
<pre class="hljs"><code><div>CREATE (:Industry {name: 'Data management'});
CREATE (:Company {name: 'Unige', mv: 'Data management', country: 'Italy', city: 'Genova', zipcode: '16100'});
CREATE (:Job {type: 'Full-time', exp_date: '2025-01-01', title: 'Pitch creator'});
CREATE (:Skill {name: 'Video editor', level: 'Advanced', score: 85});
CREATE (:Benefit {type: 'mark', ev: '110L'});

MATCH (j:Job {title: 'Pitch creator'}), 
      (c:Company {name: 'Unige'}), 
      (i:Industry {name: 'Data management'}), 
      (s:Skill {name: 'Video editor'}), 
      (b:Benefit {type: 'mark'})
CREATE (c)-[:LISTS]-&gt;(j);
CREATE (j)-[:OPERATES_IN]-&gt;(i);
CREATE (j)-[:REQUIRES]-&gt;(s);
CREATE (j)-[:OFFERS]-&gt;(b);
CREATE (c)-[:OPERATES_IN]-&gt;(i);
</div></code></pre>
<h2 id="12-neo4j-create-an-instance-of-your-schema-in-the-selected-system--0xmyonyplgmxox1je29k25bmomjepurkpxnbjeva7cu">(12) Neo4J: Create an instance of your schema in the selected system ... 0xmYonyPlGmxOx1je29k25BMOMjEPUrkPXnBJEva7cU</h2>
<pre><code>- [ ] a. You can use an already available dataset. The dataset should have a reasonable size (few Mb).
- [ ] b. Notice that selected datasets might need to be transformed in order to be used by your application. For dataset transformation, you can rely on either data transformation tools, such as Tableaux Prep (www.tableau.com), Apache Superset (superset.apache.org) Trifacta ( www.trifacta.com ), or other ETL tools such as Talend ( www.talend.com ), or scripts in your favorite language.
</code></pre>
<h2 id="13-neo4j-workload-implementation">(13) Neo4J: Workload implementation</h2>
<ul>
<li>
<p>Here follows the workload implementation on Neo4J</p>
<p>&lt;&lt; DA METTERE QUA I COMANDI E LE LORO ESECUZIONI ED EXPLAIN &gt;&gt;</p>
</li>
<li>
<p>Here are some indexes that could enhance systems' capabilities:</p>
</li>
</ul>
<pre class="hljs"><code><div>// Job node indexes
CREATE INDEX FOR (j:Job) ON (j.type);
CREATE INDEX FOR (j:Job) ON (j.exp_date);

// Company node indexes
CREATE INDEX FOR (c:Company) ON (c.city);
CREATE INDEX FOR (c:Company) ON (c.mv);
CREATE INDEX FOR (c:Company) ON (c.country);

// IndustryDomain node indexes
CREATE INDEX FOR (id:IndustryDomain) ON (id.name);

// Skill node indexes
CREATE INDEX FOR (s:Skill) ON (s.score);
CREATE INDEX FOR (s:Skill) ON (s.level);

// Benefit node indexes
CREATE INDEX FOR (b:Benefit) ON (b.type);

// Composite indexes
CREATE INDEX FOR (j:Job) ON (j.type, j.exp_date);
CREATE INDEX FOR (c:Company) ON (c.city, c.mv);
CREATE INDEX FOR (c:Company) ON (c.country, c.mv);
</div></code></pre>
<p>&lt;&lt; CONTROLLARE LE VARIE QUERY DOPO AVER MESSO GLI INDICI &gt;&gt;</p>

</body>
</html>
