<!DOCTYPE html><html><head>
      <title>Report</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\loren\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.15\crossnote\dependencies\katex\katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="linked-adm-in">Linked-adm-In: </h1>
<h3 id="foschi-lorenzo-pezzano-enrico">Foschi Lorenzo, Pezzano Enrico </h3>
<p>Final project for the Advanced Data Management course</p>
<h3 id="dataset-link">Dataset link </h3>
<p><a href="https://www.kaggle.com/datasets/arshkon/linkedin-job-postings">https://www.kaggle.com/datasets/arshkon/linkedin-job-postings</a></p>
<h3 id="nature-of-the-proposed-application">Nature of the Proposed Application </h3>
<ol>
<li>Propose a domain you are interested in and a relevant application for it (e.g.,e-commerce domain, shopping cart and session data management application). Take inspirations from datasets available online (e.g., on <a href="https://www.kaggle.com">https://www.kaggle.com</a>).</li>
<li>Provide details about the nature of the proposed application (e.g., the application is read/write intensive, requires batch processing, ...), according to what discussed in the course and corresponding system requirements (e.g., eventual/strong consistency needed, high availability needed).</li>
</ol>
<p>The proposed application is a job and industry relationship analysis tool. Its features and requirements include:</p>
<p><strong>Read/Write Intensity</strong></p>
<p>The application is predominantly read-intensive, as it emphasizes retrieving data; such as querying the skills required for a job, the benefits offered, or the industries associated with a company.<br>
Write operations occur moderately, primarily when new jobs, companies, skills, or benefits are added to the system. These updates may include inserting related attributes like market values, skill scores, or job expiration dates.</p>
<p><strong>Batch Processing</strong></p>
<p>No Batch processing, beacause the only big import can be required during initialization: no large updates to the dataset will occur.<br>
The only updates might be occasionaly integrating new company records or updated job postings.</p>
<p><strong>Consistency and Availability</strong></p>
<p>Eventual consistency is sufficient for updates to non-critical attributes, such as adding new benefits or updating a companyâ€™s market value. These changes are not immediately critical for most queries. However, for other operations like adding new jobs or companies ensuring consistency is more critical, as incomplete or incorrect relationships (e.g. a job missing its associated company) could affect query accuracy.<br>
Also, having high availability clearly is the most important goal to reach, particularly for supporting fast real-time data retrieval and queries (we want to enable people to find jobs!)</p>
<p><strong>Performance</strong></p>
<p>The system should be optimized for retrieving and filtering data (also across entities), such as:<br>
Searching for jobs based on attributes like type, location, or expiration date.<br>
Filtering companies by criteria like market value, location, or associated industries.</p>
<h3 id="conceptual-schema">Conceptual Schema </h3>
<ol start="3">
<li>Design a conceptual schema for the identified domain. The schema should include at least three associations.</li>
</ol>
<p>The following conceptual schema captures key entities and their relationships:</p>
<pre class="language-text">Nodes:
    Job(Title, Expire date, Type): Represents a specifc job posting
    Company(Name, Country, City, ZipCode, MarketValue): Represents a company
    IndustryDomain(Name): Represents an industry domain 
    Skill(Name, Level, Score): Represents skills associated with a job
    Benefit(Type, Economical Value): Represents benefits offered for a job

Relationships:
    BELONGS_TO: Links a job to an company 
    REQUIRES: Links a job to the skills it demands
    OFFERS: Links a job to the benefits it provides
    OPERATES_IN: Links a company to the industries it operates in
</pre>
<p><img src="https://github.com/user-attachments/assets/bb3e515b-c972-4ad3-827a-d7471e4cd96a" alt="Er1"></p>
<h3 id="queries">Queries: </h3>
<ol start="4">
<li>
<p>Identify a workload, i.e., a set of relevant and frequent operations, related to the chosen application. The workload should contain at least 5 structurally different operations. Describe each workload operation in natural language:</p>
<p><strong>Query 1</strong>: Find all jobs that are Full-time and expiring within the next 30 days.<br>
<strong>Q1</strong>(Job, [Job(type)<em>!, Job(expire_date)</em>!], [Job_!])</p>
<p><strong>Query 2</strong>: List the name of companies in New York with a market value greater than $1,000,000.<br>
<strong>Q2</strong>(Company, [Company(city)<em>!, Company(mv)</em>!], [Company(name)_!])</p>
<p><strong>Query 3</strong>: List name and market value of companies operating in Russia and associated with jobs that expire in more than 60 days.<br>
<strong>Q3</strong>(Job, [Company(country)<em>L, Job(expire_date)</em>!], [Company(name, mv)_L])</p>
<p><strong>Query 4</strong>: List type of jobs associated with companies operating in the Technology domain<br>
<strong>Q4</strong>(IndustryDomain, [IndustryDomain(Name)_!], [Job(type)_LO])</p>
<p><strong>Query 5</strong>: List type jobs associated with italian companies operating in the Technology domain<br>
<strong>Q5</strong>(Company, [IndustryDomain(Name)<em>O, Company(country)</em>!], [Job(type)_L])</p>
<p><strong>Query 6</strong>: Retrieve name of skills required for jobs offering benefits of type 401(k) and having a score above 70.<br>
<strong>Q6</strong>(Skill, [Skill(score)_!, Benefit(type)<em>OR], [Skill(name)</em>!])</p>
<p><strong>Query 7</strong>: Find the title of all jobs of type Internship that require skills with a level of "Beginner" and are associated with companies in Hamburg<br>
<strong>Q7</strong>(Job, [Job(type)_!, Skill(level)_R, Company(city)<em>L], [Job(title)</em>!])</p>
</li>
</ol>
<p><img src="https://github.com/user-attachments/assets/4ee6f063-1eb2-4135-add3-5e7ee2a707f9" alt="ER2"></p>
<h3 id="aggregates">Aggregates </h3>
<ol start="5">
<li>Use the aggregate-oriented design methodology (STEP 1-2-3) to design a set of aggregates for the domain and the workload at hand.</li>
</ol>
<p><strong>JobOffer:</strong><br>
{<br>
<ins>title, companyName</ins>, expire_date, type, country, city, marketValue,<br>
requires: [{skill: {level}}]<br>
}</p>
<p><strong>Company:</strong><br>
{<br>
<ins>name</ins>, marketValue, country, city,<br>
job_offers: [{job: {type}}],<br>
industryName<br>
}</p>
<p><strong>IndustryDomain:</strong><br>
{<br>
<ins>name</ins>,<br>
operated: [{ company: [{ job: {type} }] }]<br>
}</p>
<p>Note: dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs</p>
<p><strong>Skill:</strong><br>
{<br>
<ins>name</ins>,score,<br>
provides: [{benefit: {type}}]<br>
}</p>
<p>Note: double n-n relationship unpacked into a single list: we're only interested in benefits that skills provides, regardless of the jobs</p>
<h3 id="design-in-mongodb">Design in MongoDB </h3>
<ol start="6">
<li>Design in MongoDB:<br>
a. Design a schema for MongoDB (including partition keys and indexes), starting from step 5, using the approaches/methodologies proposed in the course.<br>
b. Specify each operation of the workload in the language supported by MongoDB</li>
</ol>
<p><strong>Queries associated with Skill: Q6</strong></p>
<p>Selection attributes for Q6: {score, type} <!-- benefit type --></p>
<p>The aggregate will remain the same...</p>
<p><strong>Skill:</strong><br>
{<br>
<ins>name</ins>,score,<br>
provides: [{benefit: {type}}]</p>
<p>Then MongoDB will add the _id:</p>
<p>{<br>
_id, <ins>name</ins>,score,<br>
provides: [{benefit: {type}}]<br>
}</p>
<p><strong>About indexes</strong>: We have to support the shard key via an index, either with full or compound index with the shard key as a prefix. Then, for enforcing uniqueness we would also need a unique index on the shard key itself (otherwise the uniqueness constraint across shards can't be enforced). Nevertheless, we opt to put a index which contains the full shard key as a prefix of the index = {score, type} and avoid enforcing uniqueness across partitions (we don't consider the skill name to be so crucial to be actually unique across shards).</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.skills.createIndex({ score: 1, "provides.benefit.type": 1 });
</code></pre><ul>
<li>Shard collection</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.adminCommand({
  shardCollection: "db.skill",
  key: { score: 1, "provides.benefit.type": 1 }
});
</code></pre><ul>
<li>Q6:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.skills.find({score: {$gt: 70}, "provides.benefit.type": "401(k)"}, {name: 1, _id: 0});
</code></pre><p>Note: Remembering that there's no such a thing as "CREATE TABLE" in MongoDB we avoid reporting here insert commands of example data for the collection.</p>
<p><strong>Queries associated with IndustryDomain: Q4</strong><br>
Selection attributes for Q4: {name} <!-- IndustryDomain name --></p>
<p>The aggregate will remain the same...</p>
<p><strong>IndustryDomain:</strong><br>
{<br>
<ins>name</ins>,<br>
operated: [{ company: [{ job: {type} }] }] <!-- dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs--><br>
}</p>
<p>Then MongoDB will add the _id:</p>
<p>{<br>
_id, <ins>name</ins>,<br>
operated: [{ company: [{ job: {type} }] }] <!-- dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs--><br>
}</p>
<p><strong>About indexes</strong>:</p>
<ul>
<li>A unique index on the partition key, which is also the aggregate key = {name}</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.industryDomains.createIndex({ name: 1 }, { unique: true });
</code></pre><ul>
<li>Shard collection</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.adminCommand({
  shardCollection: "db.industryDomain",
  key: { name: 1 }
});
</code></pre><ul>
<li>Q4:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.industryDomains.aggregate([
  {
    $match: {
      name: "Technology"
    }
  },
  {
    $unwind: "$operated"
  },
  {
    $unwind: "$operated.company"
  },
  {
    $unwind: "$operated.company.job"
  },
  {
    $project: {
      _id: 0,
      jobType: "$operated.company.job.type"
    }
  },
  {
    $group: {
      _id: null,
      jobTypes: { $addToSet: "$jobType" }
    }
  },
  {
    $project: {
      _id: 0,
      jobTypes: 1
    }
  }
]);
</code></pre><p><strong>Queries associated with Company: Q2, Q5</strong><br>
Selection attributes for Q2: {city, mv}</p>
<p>Selection attributes for Q5: {country, industryName} <!-- IndustryDomain name --></p>
<p>The aggregate will remain the same...</p>
<p><strong>Company:</strong><br>
{<br>
<ins>name</ins>, marketValue, country, city,<br>
job_offers: [{job: {type}}],<br>
industryName <!-- simple attribute because it comes from a (1,1) association --><br>
}</p>
<p>Then MongoDB will add the _id:</p>
<p>{<br>
_id, <ins>name</ins>, marketValue, country, city,<br>
job_offers: [{job: {type}}],<br>
industryName <!-- simple attribute because it comes from a (1,1) association --><br>
}</p>
<p><strong>About indexes</strong>:</p>
<ul>
<li>Given that the intersection between selection attributes in Q2 and Q5 is empty: instead of having a single non-unique index on {city, mv, country, industryName} we choose to separetely support both queries by creating two separate non-unique indexes onto them:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>    db.companies.createIndex({ city: 1, mv: 1 });
    db.companies.createIndex({ country: 1, industryName: 1 });
</code></pre><p>Then, after having thought about both queries, we create a mixed unique index for sharding and to then support the uniqueness of name with a compound index. This index has to be unique to support uniqueness across all shards.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>    db.companies.createIndex({ city: 1, country: 1 },{ unique: true });
</code></pre><ul>
<li>A compound-unique index which contains the full shard key as a prefix of the index:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>    db.companies.createIndex(
      { city: 1, country: 1, name: 1 },
      { unique: true }
    );
</code></pre><ul>
<li>Shard collection</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>    db.adminCommand({
      shardCollection: "db.Company",
      key: { city: 1, country: 1 }
    });
</code></pre><ul>
<li>Q2:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.companies.find({ city: "New York", mv: { $gt: 1000000 } }, { name: 1, _id: 0 });
</code></pre><ul>
<li>Q5:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.companies.aggregate([
  {
    $match: {
      country: "Italy",
      industryName: "Technology"
    }
  },
  {
    $unwind: "$job_offers"
  },
  {
    $project: {
      _id: 0,
      jobType: "$job_offers.job.type"
    }
  },
  {
    $group: {
      _id: null,
      jobTypes: { $addToSet: "$jobType" }
    }
  },
  {
    $project: {
      _id: 0, // the grouping creates again an _id :(
      jobTypes: 1
    }
  }
]);
</code></pre><p><strong>Queries associated with JobOffer: Q1, Q3, Q7</strong><br>
Selection attributes for Q1: {type, expire_date}</p>
<p>Selection attributes for Q3: {country, expire_date}</p>
<p>Selection attributes for Q7: {type, city, level}</p>
<p>The aggregate will remain the same...</p>
<p><strong>JobOffer:</strong><br>
{<br>
<ins>title, companyName</ins>, expire_date, type, country, city, marketValue,<br>
requires: [{skill: {level}}]<br>
}</p>
<p>Then MongoDB will add the _id:</p>
<p>{<br>
_id, <ins>title, companyName</ins>, expire_date, type, country, city, marketValue,<br>
requires: [{skill: {level}}]<br>
}</p>
<p><strong>About indexes</strong>:</p>
<ul>
<li>We observe that type appears in both Q1 and Q7 while expire_date in both Q1 and Q3: so we have an empty intersection but a partial overlap that can be leveraged to support multiple queries efficiently.<br>
Consequently, we can think about:
<ul>
<li>A composite index on {type, expire_date, city, level}: mongo uses a prefix for filtering so this will support both Q1 and Q7</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.jobOffers.createIndex({ type: 1, expire_date: 1, city: 1, level: 1 });
</code></pre><ul>
<li>We can follow a similar approach to combine Q1 and Q3 obtaining an index on {expire_date, type, country}</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.jobOffers.createIndex({ expire_date: 1, type: 1, country: 1 });
</code></pre><ul>
<li>Then, we think about having a compound unique index to enforce key constraint on the aggregate key {title, companyName}: given that type and expire_date are in partial overlap between queries we select them as a shard key. Here the unique indexes:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.jobOffers.createIndex(
  { type: 1, expire_date: 1 },
  { unique: true }
);

db.jobOffers.createIndex(
  { type: 1, expire_date: 1, title: 1, companyName: 1 },
  { unique: true }
);
</code></pre></li>
<li>Shard collection</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>db.adminCommand({
  shardCollection: "db.JobOffer",
  key: { type: 1, expire_date: 1 }
});
</code></pre><ul>
<li>Q1:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.jobOffers.find(
  {
    type: "Full-time",
    expire_date: { $lte: new Date(new Date().setDate(new Date().getDate() + 30)) }
  },
  {
    _id: 0
  }
);
</code></pre><ul>
<li>Q3:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.jobOffers.aggregate([
  {
    $match: {
      country: "Russia",
      expire_date: { $gt: new Date(new Date().setDate(new Date().getDate() + 60)) }
    }
  },
  {
    $project: {
      _id: 0,
      companyName: 1,
      marketValue: 1
    }
  },
  {
    $group: {
      _id: "$companyName", // Group by company name
      marketValue: { $first: "$marketValue" } // Collect the first market value (one value per company!)
    }
  }
]);
</code></pre><p>Side note on this Q3: $first is used in MongoDB grouping to select the first encountered value of a field (e.g., marketValue) that is not part of the grouping key, providing a simple and efficient way to handle such fields without requiring computation.</p>
<ul>
<li>Q7:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>  db.jobOffers.find(
  {
    type: "Internship",
    city: "Hamburg",
    "requires.skill.level": "Beginner"
  },
  {
    _id: 0,
    title: 1
  }
);
</code></pre><h3 id="design-in-cassandra">Design in Cassandra </h3>
<ol start="7">
<li>Design in Cassandra:<br>
a. Design schema for Cassandra (including partition keys and indexes), starting from step 5, using the approaches/methodologies proposed in the course.<br>
b. Specify in CQL each operation of the workload.</li>
</ol>
<p><strong>Queries associated with Skill: Q6</strong><br>
Selection attributes for Q6: {score, type} <!-- benefit type --></p>
<p><strong>Skill:</strong><br>
{<br>
<ins>name</ins>,score,<br>
provides: [{benefit: {type}}] <!-- double n-n relationship unpacked into a single list: we're only interested in benefits that skills provides, regardless of the jobs --><br>
}</p>
<ul>
<li>Given that we only have one query, we can safely select {score} as partition key, while for the primary key we have to add the aggregate key "name" in order to have the aggregate identifier. We obtain:
<ul>
<li>Partition key = {score}</li>
<li>Primary key = {score, name} with name as clustering column</li>
</ul>
</li>
</ul>
<p>However, we have still purposely ignored the selection on benefit type!</p>
<p>As an <strong>important note</strong>, we can't create a custom type because this would enforce the set to be frozen and therefore disallowing us to create an INDEX on provides.</p>
<ul>
<li>Here is the CREATE command in Cassandra:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE TABLE Skills (
    name text,
    score int,
    provides set&lt;text&gt;,
    PRIMARY KEY (score, name)
);

CREATE INDEX ON Skills (provides);
</code></pre><ul>
<li>Q6:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT name
FROM Skills
WHERE score = 71 AND provides CONTAINS '401(k)';
</code></pre><p><strong>Queries associated with IndustryDomain: Q4</strong><br>
Selection attributes for Q4: {name} <!-- IndustryDomain name --></p>
<p><strong>IndustryDomain:</strong><br>
{<br>
<ins>name</ins>,<br>
operated: [{ company: [{ job: {type} }] }] <!-- dobule n-n relationship kept as list[lists] to semanthically keep the companies for further needs--><br>
}</p>
<ul>
<li>Given that name is both the only selection attribute and the aggregate key we only have to select it as Partition Key!
<ul>
<li>Partition key = {name}</li>
</ul>
</li>
<li>Here are the CREATE commands in Cassandra:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE TYPE job_t (
    type text
);

CREATE TYPE company_t (
    job list&lt;frozen&lt;job_t&gt;&gt;
);

CREATE TABLE IndustryDomain (
    name text PRIMARY KEY,
    operated list&lt;frozen&lt;company_t&gt;&gt;
);
</code></pre><ul>
<li>Q4:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT operated 
FROM IndustryDomain 
WHERE name = 'Technology';
</code></pre><p><strong>Queries associated with Company: Q2, Q5</strong><br>
Selection attributes for Q2: {city, mv}</p>
<p>Selection attributes for Q5: {country, industryName} <!-- IndustryDomain name --></p>
<p><strong>Company:</strong><br>
{<br>
<ins>name</ins>, marketValue, country, city,<br>
job_offers: [{job: {type}}],<br>
industryName <!-- simple attribute because it comes from a (1,1) association --><br>
}</p>
<ul>
<li>Unluckily, the intersection between Q2 and Q5 selection attributes is empty: the only solution is to split the aggregate into two column-families!</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE TYPE job_t (
    type text
);

CREATE TABLE Company2 (
    city text,
    marketValue double,
    name text,
    country text,
    job_offers list&lt;frozen&lt;job_t&gt;&gt;,
    industryName text,
    PRIMARY KEY ((city, marketValue), name)
);

CREATE TABLE Company5 (
    city text,
    marketValue double,
    name text,
    country text,
    job_offers list&lt;frozen&lt;job_t&gt;&gt;,
    industryName text,
    PRIMARY KEY ((country, industryName), name)
);
</code></pre><p>Company2 will be used for executing Q2 and Company5 for executing Q5.</p>
<p>A further analysis can lead us to optimize, for example, C5 table by removing unnecessary fields (we still have C2 for other fields if required, so no needs to include extra field on a table that should be mainly tailored to allow the execution of query 5.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE TABLE Company5 (
    country text,
    industryName text,
    name text,
    job_offers list&lt;frozen&lt;job_t&gt;&gt;,
    PRIMARY KEY ((country, industryName), name)
);
</code></pre><ul>
<li>Q2:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT name 
FROM Company2 
WHERE city = 'New York' AND marketValue &gt; 1000000.0;
</code></pre><ul>
<li>Q5:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT job_offers 
FROM Company5 
WHERE country = 'Italy' AND industryName = 'Technology';
</code></pre><p><strong>Queries associated with JobOffer: Q1, Q3, Q7</strong><br>
Selection attributes for Q1: {type, expire_date}</p>
<p>Selection attributes for Q3: {country, expire_date}</p>
<p>Selection attributes for Q7: {type, city, level}</p>
<p><strong>JobOffer:</strong><br>
{<br>
<ins>title, companyName</ins>, expire_date, type, country, city, marketValue,<br>
requires: [{skill: {level}}]<br>
}</p>
<ul>
<li>Given our partial overlap we can think to carefully design this solution. Here are two candidate pairings:
<ul>
<li>
<p>Option 1: Combine Q1 and Q3</p>
<ul>
<li>Shared attribute: expire_date.</li>
<li>Partitioning by expire_date allows efficient filtering for both queries.</li>
</ul>
</li>
<li>
<p>Option 2: Combine Q1 and Q7</p>
<ul>
<li>Shared attribute: type.</li>
<li>Partitioning by type allows efficient filtering for both queries.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We could decide to opt for mixing Q1 and Q3 because expire_date is time-based and therefore with high selection factor (we have less types then expire_dates so makes sense to group the latter) --&gt; We'll see later on that this approach brings some problems!</p>
<p>Also, as seen before, we opt for a list<text> to allow the INDEX creation for Q7's level selection.</text></p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE TABLE Job1_3 (
    expire_date DATE,
    type text,
    country text,
    title text,
    companyName text,
    city text,
    marketValue double,
    requires list&lt;text&gt;,
    PRIMARY KEY (expire_date, type, country, title, companyName)
);

CREATE TABLE Job7 (
    expire_date DATE,
    type text,
    country text,
    title text,
    companyName text,
    city text,
    marketValue double,
    requires list&lt;text&gt;,
    PRIMARY KEY ((type, city), title, companyName)
);

CREATE INDEX ON Job7 (requires);
</code></pre><p>A further analysis can lead us to optimize tables by removing unnecessary fields.<br>
Also, unfortunately, we see that based on Job1_3 we can't execute Q1 and Q3 without either creating secondary indexes or by ALLOW FILTERING (e.g expire_date is a range selection and therefore has to appear as the last). So we opt to further divide the two tables:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE TABLE Job1 (
    expire_date DATE,
    type text,
    title text,
    companyName text,
    PRIMARY KEY (type, expire_date, title, companyName)
);

CREATE TABLE Job3 (
    expire_date DATE,
    country text,
    title text,
    marketValue double,
    companyName text,
    PRIMARY KEY (country, expire_date, title, companyName)
);

CREATE TABLE Job7 (
    type text,
    city text,
    title text,
    companyName text,
    requires list&lt;text&gt;,
    PRIMARY KEY ((type, city), title, companyName)
);

CREATE INDEX ON Job7 (requires);
</code></pre><ul>
<li>Q1:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT * 
FROM Job1 
WHERE type = 'Full-time' AND expire_date &lt;= toDate(now()) + 30;
</code></pre><ul>
<li>Q3:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT companyName, marketValue 
FROM Job3 
WHERE country = 'Russia' AND expire_date &gt; toDate(now()) + 60;
</code></pre><ul>
<li>Q7:</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT title 
FROM Job7 
WHERE type = 'Internship' 
  AND city = 'Hamburg' 
  AND requires CONTAINS 'Beginner';
</code></pre><h3 id="design-in-neo4j">Design in Neo4J </h3>
<ol start="8">
<li>Design in Neo4J:<br>
a. Design a schema for Neo4j, using the approaches/methodologies proposed in the course.<br>
b. Specify in Neo4j each operation of the workload.</li>
</ol>
<p><img src="https://github.com/user-attachments/assets/3680f296-22f0-4a47-8fa3-324540351316" alt="graph"></p>
<p>Query workload in Neo4J (from 1 to 7):</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (j:Job)
WHERE j.type = 'Full-time'
  AND date(substring(j.exp_date, 0, 10)) &lt;= date() + duration({days: 30})
RETURN j

MATCH (c:Company)
WHERE c.city = 'New York' AND c.mv &gt; 1000000
RETURN c.name

MATCH (c:Company {country: 'Russia'})-[:LISTS]-&gt;(j:Job)
WHERE date(substring(j.exp_date, 0, 10)) &lt;= date() + duration({days: 60})
RETURN DISTINCT c.name, c.mv

MATCH (id:Industry)&lt;-[:OPERATES_IN]-(c:Company)-[:LISTS]-&gt;(j:Job)
WHERE id.name = 'Technology'
RETURN DISTINCT j.type

MATCH (id:Industry)&lt;-[:OPERATES_IN]-(c:Company {country: 'Italy'})-[:LISTS]-&gt;(j:Job)
WHERE id.name = 'Technology'
RETURN DISTINCT j.type

MATCH (s:Skill)&lt;-[:REQUIRES]-(j:Job)-[:OFFERS]-&gt;(b:Benefit)
WHERE s.score &gt; 70 AND b.type = '401(k)'
RETURN DISTINCT s.name

MATCH (j:Job {type: 'Internship'})-[:REQUIRES]-&gt;(s:Skill {level: 'Beginner'}), 
      (j)&lt;-[:LISTS]-(c:Company {city: 'Hamburg'})
RETURN j.title
</code></pre><p>Note: when it comes on choosing whether to put "WHERE" or leveraging "{...}" the decision relies on both flexibility and clarity. For complex conditions we chose WHERE, while for simple conditions of the "starting" node in the path we opted for a direct {...} inside the MATCH parenthesis.</p>
<h3 id="system-s-choice">System S choice: </h3>
<ol start="9">
<li>Discuss which, among the three systems, is the most suitable to be used as back-end for your application. Motivate your choice, taking into account the features of your application (step 2) and the identified workload (step 4). Let S be the selected system.</li>
</ol>
<p>Given that our application is:</p>
<ul>
<li>predominanty read-intensive</li>
<li>with high avaibility constraints</li>
<li>some consistency constraints</li>
<li>no need of batch-processing</li>
<li>highly relational queries</li>
</ul>
<p>We select <strong>Neo4J</strong> as system S for suitable backend for our application. This is driven by the following reasonings:</p>
<ul>
<li>The application is centered on relationships and traversals (e.g linking jobs to companies, industries, skills, and benefits), as graph databases benefits provide.</li>
<li>Cypher queries easily handles our workload, as opposed to MongoDB.</li>
<li>Our modelled graph is able to direclty reflect the conceptual schema, as opposed to Cassandra.</li>
<li>Perfectly suitable for high avaibility and read-intensive data</li>
<li>CA tailored</li>
</ul>
<p>The only weakness is with respect to scalability of writes, but as we said the percentage of write operations is hugely lower than the write one (also, write operations are limited to little additions of new jobs when occasionaly they pop-up).</p>
<ul>
<li>
<p>We discarded MongoDB due to:</p>
<ul>
<li>unintuitive relationships handling</li>
<li>not so optimized aggregation pipelines on most of the queries (due to them being highly relational)</li>
</ul>
</li>
<li>
<p>We discarded Cassandra due to:</p>
<ul>
<li>Multiple denormalized tables, originated to a schema design that has to be tailored to specific queries (that present multiple disjoint scenarios with respect to selection attributes)</li>
<li>No query flexibility for future workload changes, highly probable in this dynamic world of jobs.</li>
</ul>
</li>
</ul>
<h3 id="neo4j-configuration-details">Neo4J: Configuration details </h3>
<ol start="10">
<li>Provide details about the system configuration needed in system S for storing/processing your data according to the chosen application.</li>
</ol>
<p>We need:</p>
<ul>
<li>Neo4J Aura instance to implement our system</li>
<li>Query performance optimization by indexing when feasible (see (13))</li>
<li>High RAM size for data traversal (Neo4J instance will be enough for our dataset's size)</li>
</ul>
<p>If really implementing a scalable business solution, we would also need a clustering mechanisms to ensure high avaibility and causal consistency (let's remember that Neo4J is a <strong>CA</strong> system and it relies on causal consistency). Let's make an example configuration:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>causal_clustering.enabled=true
causal_clustering.minimum_core_cluster_size_at_runtime=3
</code></pre><p>Then, when deploying Neo4j for a read-intensive workload with high availability and potential fault tolerance, the "R + W &gt; N" rule becomes crucial: R (# of replicas that respond to read requests) and W (# of core nodes required for a successful write) must exceed the total number of N (core nodes in the cluster).</p>
<p>Keeping in mind that in Neo4J each write operation is replicated across core nodes to keep consistency we have to carefully choose values for R, W and N.</p>
<ul>
<li>As said before N = 3 (so with a fault tolerance of 1 node failure and therefore a minimum quorum of 2 nodes)</li>
<li>We can set W = 2 (at minimum 2 nodes have to commit a write for it being successfull)<pre data-role="codeBlock" data-info="" class="language-text"><code>dbms.cluster.minimum_core_write_quorum=2
</code></pre></li>
<li>We can set R = 2 (at least 2 replicas have to respond to that request)<pre data-role="codeBlock" data-info="" class="language-text"><code>causal_clustering.read_replica_count=2
</code></pre></li>
<li>R + W in this scenario = 4, that indeed is higher then N = 3!</li>
</ul>
<p>Then, to scale-up in our read-intensive application, we would need to increase the read replicas.</p>
<p>For example, the following might be a feasible <em>job board</em> scenario, in which the course concepts could be highly applied:</p>
<p>To scale up in our read-intensive application we would primarily focus on increasing the number of read replicas, which in Neo4j are dedicated nodes that serve only read queries, offloading the weight from the core nodes and allowing the system to handle significantly higher query volumes.</p>
<p>For <strong>example</strong>, in our job-board scenario mentioned above, the system must handle a high volume of user queries. Since the majority of these operations are read-only, the read replicas can efficiently handle these requests without impacting the performance of the core nodes.</p>
<p>So, in our previous example, as the number of users grows, we can step-by-step increase the number of read replicas depending on the query load; and since read replicas only need to synchronize with the core nodes periodically they can scale horizontally (and also being geographically replicated) without requiring changes to the core cluster configuration!</p>
<h3 id="neo4j-schema-details">Neo4J: Schema details </h3>
<ol start="11">
<li>Create the logical schema in system S</li>
</ol>
<p>Given Neo4J schema-less nature <strong>we don't have to provide any schema detail</strong> (like in Cassandra for example, where we would have needed some table specifications). Here we just need to dynamically create nodes and their relationships, as we'll do in the next step.<br>
For simplicity, Jobs will be considered as merely identified by their title.<br>
Nevertheless, here follows a basic <strong>example</strong> on how the nodes should appear in our database insertion:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE (:Industry {name: 'Data management'});
CREATE (:Company {name: 'Unige', mv: 'Data management', country: 'Italy', city: 'Genova', zipcode: '16100'});
CREATE (:Job {type: 'Full-time', exp_date: '2025-01-01', title: 'Pitch creator'});
CREATE (:Skill {name: 'Video editor', level: 'Advanced', score: 85});
CREATE (:Benefit {type: 'mark', ev: '110L'});

MATCH (j:Job {title: 'Pitch creator'}), 
      (c:Company {name: 'Unige'}), 
      (i:Industry {name: 'Data management'}), 
      (s:Skill {name: 'Video editor'}), 
      (b:Benefit {type: 'mark'})
CREATE (c)-[:LISTS]-&gt;(j);
CREATE (j)-[:OPERATES_IN]-&gt;(i);
CREATE (j)-[:REQUIRES]-&gt;(s);
CREATE (j)-[:OFFERS]-&gt;(b);
CREATE (c)-[:OPERATES_IN]-&gt;(i);
</code></pre><h3 id="neo4j-graph-details">Neo4J: Graph details </h3>
<ol start="12">
<li>Create an instance of your schema in the selected system, according to the logical schema just created.</li>
</ol>
<p>We started from the linkedin-job-postings database and we continued by transforming it to meet our needs (removing unused fields and adding market value &amp; economical value for queries enrichment).</p>
<p>These are our dataset links:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/data/company.csv

https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/data/job.csv

https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/data/benefit.csv

https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/data/industry.csv

https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/data/skill.csv

https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/data/relationships.csv
</code></pre><p>We noted that, when loading the last CSV file (for the relationships), Neo4J was very slow due to its unfeasability on handling batch processing.</p>
<h3 id="neo4j-workload-implementation">Neo4J: Workload implementation </h3>
<ol start="13">
<li>Implement the workload in system S.</li>
</ol>
<p>Here follows the workload implementation on Neo4J together with their <strong>execution explanation</strong>. We also decided to show some meaninfgul results with some indexes that could enhance systems' capabilities.</p>
<p>Once Neo4j has located the starting node, traversals through relationships are very efficient (O(1) basically). However... finding the starting node in a query is where indexes come into play!</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (j:Job)
WHERE j.type = 'Full-time'
  AND date(substring(j.exp_date, 0, 10)) &lt;= date() + duration({days: 30})
RETURN j
</code></pre><p><img src="https://github.com/user-attachments/assets/8957184d-45be-4ed0-8dfb-08ed394270a4" alt="1 1"></p>
<hr>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (c:Company {country: 'Russia'})-[:LISTS]-&gt;(j:Job)
WHERE date(substring(j.exp_date, 0, 10)) &lt;= date() + duration({days: 60})
RETURN DISTINCT c.name, c.mv
</code></pre><p><img src="https://github.com/user-attachments/assets/a63731d5-9965-4008-95c7-53ce3001dfeb" alt="1 2"></p>
<hr>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (j:Job {type: 'Internship'})-[:REQUIRES]-&gt;(s:Skill {level: 'Beginner'}), 
      (j)&lt;-[:LISTS]-(c:Company {city: 'Hamburg'})
RETURN j.title
</code></pre><p><img src="https://github.com/user-attachments/assets/3ff1e947-fcee-4285-bde7-3dfc64d6f64c" alt="1 3"></p>
<hr>
<p>Let's put some indexes:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE INDEX FOR (j:Job) ON (j.type);
CREATE INDEX FOR (j:Job) ON (j.exp_date);
</code></pre><p>The first query changed its execution plan in the following way, while the other two remained unchanged. In our opinion this can be related to the fact that in the first query the index matched with all the selection attributes.</p>
<p><img src="https://github.com/user-attachments/assets/2d0a92b3-67e1-49ef-981c-9f5de6e1a473" alt="1 1_idx"></p>
<hr>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (c:Company)
WHERE c.city = 'New York' AND c.mv &gt; 1000000
RETURN c.name
</code></pre><p><img src="https://github.com/user-attachments/assets/6e9239c4-1ce4-4519-88ca-d60c6a996472" alt="2 1"></p>
<hr>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (id:Industry)&lt;-[:OPERATES_IN]-(c:Company {country: 'Italy'})-[:LISTS]-&gt;(j:Job)
WHERE id.name = 'Technology'
RETURN DISTINCT j.type
</code></pre><p><img src="https://github.com/user-attachments/assets/29e3938e-0787-41de-850c-91ecb4278164" alt="2 2"></p>
<hr>
<p>Let's put some indexes:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE INDEX FOR (c:Company) ON (c.city);
CREATE INDEX FOR (c:Company) ON (c.mv);
CREATE INDEX FOR (c:Company) ON (c.country);
</code></pre><p>The first query changed its execution plan in the following way, while the other one remained unchanged. In our opinion this can be related to the fact that in the second query the automatically created unique index on the primary key field "name" was indeed used (so no need to use the new ones).</p>
<p><img src="https://github.com/user-attachments/assets/cade8357-bfc9-4583-9b2b-1a6ff8bc29ff" alt="2 1_2"></p>
<hr>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (id:Industry)&lt;-[:OPERATES_IN]-(c:Company)-[:LISTS]-&gt;(j:Job)
WHERE id.name = 'Technology'
RETURN DISTINCT j.type
</code></pre><p><img src="https://github.com/user-attachments/assets/ca42b111-7e40-4cb3-884d-90789a7b2f26" alt="3"></p>
<hr>
<p>In this case the following index already exists by Neo4J, for the reasons explained before.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE INDEX FOR (id:IndustryDomain) ON (id.name);
</code></pre><hr>
<pre data-role="codeBlock" data-info="" class="language-text"><code>MATCH (s:Skill)&lt;-[:REQUIRES]-(j:Job)-[:OFFERS]-&gt;(b:Benefit)
WHERE s.score &gt; 70 AND b.type = '401(k)'
RETURN DISTINCT s.name
</code></pre><p><img src="https://github.com/user-attachments/assets/fe68911c-01a4-465a-b7fa-60e8634c8f80" alt="4"></p>
<hr>
<p>Let's put some indexes:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CREATE INDEX FOR (s:Skill) ON (s.score);
CREATE INDEX FOR (s:Skill) ON (s.level);
</code></pre><p>Again, these indexes are not used due to the benefit.type unique index being already present.</p>
<hr>
<h3 id="model-in-rdfs--owl-the-main-classes-and-properties">Model in RDFS / OWL the main classes and properties </h3>
<ol start="14">
<li>Model in RDFS / OWL the main classes and the main properties corresponding to the entities and associations in the conceptual schema (step 3)</li>
</ol>
<p><strong>a.</strong> (Specify classes and properties) + for each property, specify the corresponding domain and range.</p>
<p>For simplicity, Jobs will be considered as merely identified by their title.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>@prefix ex: &lt;http://example.org/schema#&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

# Classes:

ex:Job a rdfs:Class .
ex:Company a rdfs:Class .
ex:IndustryDomain a rdfs:Class .
ex:Skill a rdfs:Class .
ex:Benefit a rdfs:Class .

# (Subject to Object) Properties:

ex:belongsTo a rdf:Property ; rdfs:domain ex:Job ; rdfs:range ex:Company .
ex:requires a rdf:Property ; rdfs:domain ex:Job ; rdfs:range ex:Skill .
ex:offers a rdf:Property ; rdfs:domain ex:Job ; rdfs:range ex:Benefit .
ex:operatesIn a rdf:Property ; rdfs:domain ex:Company ; rdfs:range ex:IndustryDomain .

# (Subject to Literal) Properties

# Job
ex:jobTitle a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range xsd:string .

ex:jobType a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range xsd:string .

ex:expireDate a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range xsd:date .

# Company
ex:companyName a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string .

ex:country a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string .

ex:city a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string .

ex:zipCode a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string .

ex:marketValue a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:decimal .

# Attributes for IndustryDomain
ex:industryName a rdf:Property ;
    rdfs:domain ex:IndustryDomain ;
    rdfs:range xsd:string .

# Skill
ex:skillName a rdf:Property ;
    rdfs:domain ex:Skill ;
    rdfs:range xsd:string .

ex:skillLevel a rdf:Property ;
    rdfs:domain ex:Skill ;
    rdfs:range xsd:string .

ex:skillScore a rdf:Property ;
    rdfs:domain ex:Skill ;
    rdfs:range xsd:decimal .

# Benefit
ex:benefitType a rdf:Property ;
    rdfs:domain ex:Benefit ;
    rdfs:range xsd:string .

ex:economicalValue a rdf:Property ;
    rdfs:domain ex:Benefit ;
    rdfs:range xsd:decimal .
</code></pre><p><strong>b.</strong> Express which classes are equivalent and which ones are disjoint.</p>
<p>In RDFS and OWL the semantics expresses that:</p>
<ul>
<li>
<p><strong>Open World Assumption</strong>: The absence of a triple in a graph does not imply that the corresponding statement does not hold</p>
</li>
<li>
<p><strong>No Unique Name Assumption</strong>: differently named individuals can denote the same thing</p>
</li>
</ul>
<p>Given that, we can for example express that "Job" and "JobOffer" are indeed the same concept in our domain:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:JobOffer a owl:Class ;
owl:equivalentClass ex:Job .
</code></pre><p>These are instead all disjoint specifications:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:Job owl:disjointWith ex:Company, ex:IndustryDomain, ex:Skill, ex:Benefit .
ex:Company owl:disjointWith ex:IndustryDomain, ex:Skill, ex:Benefit .
ex:IndustryDomain owl:disjointWith ex:Skill, ex:Benefit .
ex:Skill owl:disjointWith ex:Benefit .
</code></pre><p><strong>c.</strong> Specify (or add) at least an inverse property.</p>
<p>Let's repeat once again all the (Subject to Object) properties in order to define their possible inverse relationships:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:belongsTo a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range ex:Company ;
    owl:inverseOf ex:offersJob .

ex:requires a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range ex:Skill ;
    owl:inverseOf ex:isRequired .

ex:offers a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range ex:Benefit ;
    owl:inverseOf ex:isOffered .

ex:operatesIn a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range ex:IndustryDomain ;
    owl:inverseOf ex:hasCompany .
</code></pre><p>For example we can have:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:offersJob a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range ex:Job ;
    owl:inverseOf ex:belongsTo .
</code></pre><p><strong>d.</strong> For all the modeled properties, specify whether they are functional (or inverse functional).</p>
<ul>
<li>The only Class Property to be functional is belongsTo, because if a Job belongs to CompanyA and CompanyB; these two Companies are indeed the same Company.</li>
<li>There are no Inverse Functional Class Properties</li>
<li>All the Literal Properties are functional (there aren't any entities that can have multiple literal values, e.g a single Job Offer can't have two different expire dates, therefore if a Job has two expire_dates they're indeed the same expire_date).</li>
<li>Only the PRIMARY KEY literals are also inverse functional (e.g if two Companies have the same name, the two Companies are indeed the same Company).</li>
</ul>
<pre data-role="codeBlock" data-info="" class="language-text"><code># Subject to Object Properties
ex:belongsTo a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range ex:Company ;
    a owl:FunctionalProperty .

# Subject to Literal Properties - Job
ex:jobTitle a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty, owl:InverseFunctionalProperty .

ex:jobType a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty .

ex:expireDate a rdf:Property ;
    rdfs:domain ex:Job ;
    rdfs:range xsd:date ;
    a owl:FunctionalProperty .

# Subject to Literal Properties - Company
ex:companyName a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty, owl:InverseFunctionalProperty .

ex:country a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty .

ex:city a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty .

ex:zipCode a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty .

ex:marketValue a rdf:Property ;
    rdfs:domain ex:Company ;
    rdfs:range xsd:decimal ;
    a owl:FunctionalProperty .

# Attributes for IndustryDomain
ex:industryName a rdf:Property ;
    rdfs:domain ex:IndustryDomain ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty, owl:InverseFunctionalProperty .

# Subject to Literal Properties - Skill
ex:skillName a rdf:Property ;
    rdfs:domain ex:Skill ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty, owl:InverseFunctionalProperty .

ex:skillLevel a rdf:Property ;
    rdfs:domain ex:Skill ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty .

ex:skillScore a rdf:Property ;
    rdfs:domain ex:Skill ;
    rdfs:range xsd:decimal ;
    a owl:FunctionalProperty .

# Subject to Literal Properties - Benefit
ex:benefitType a rdf:Property ;
    rdfs:domain ex:Benefit ;
    rdfs:range xsd:string ;
    a owl:FunctionalProperty, owl:InverseFunctionalProperty .

ex:economicalValue a rdf:Property ;
    rdfs:domain ex:Benefit ;
    rdfs:range xsd:decimal ;
    a owl:FunctionalProperty .
</code></pre><h3 id="model-rdf-instances">Model RDF instances </h3>
<ol start="15">
<li>Model in RDF some instances to populate your schema. In addition:<br>
a. Relate instances to the corresponding class or property.<br>
b. Clarify which individuals are identical and which ones are different.</li>
</ol>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:SwEng a ex:Job ;
    ex:jobTitle "Software Engineer" ;
    ex:jobType "Full-time" ;
    ex:expireDate "2025-02-15"^^xsd:date ;
    ex:belongsTo ex:GueCorp ;
    ex:requires ex:Pitch, ex:SQL ;
    ex:offers ex:HI, ex:TaxBenefit .

ex:GueCorp a ex:Company ;
    ex:companyName "GuerriniCorp" ;
    ex:country "Italy" ;
    ex:city "Genoa" ;
    ex:zipCode "16165" ;
    ex:marketValue "80000000.00"^^xsd:decimal ;
    ex:operatesIn ex:Creativity .

ex:Creativity a ex:IndustryDomain ;
    ex:industryName "Creativity" .

ex:Pitch a ex:Skill ;
    ex:skillName "Elevator Pitch" ;
    ex:skillLevel "Intermediate" ;
    ex:skillScore "85.0"^^xsd:decimal .

ex:SQL a ex:Skill ;
    ex:skillName "SQL" ;
    ex:skillLevel "Advanced" ;
    ex:skillScore "90.0"^^xsd:decimal .

ex:HI a ex:Benefit ;
    ex:benefitType "Health Insurance" ;
    ex:economicalValue "5000.00"^^xsd:decimal .

ex:TaxBenefit a ex:Benefit ;
    ex:benefitType "401(k)" ;
    ex:economicalValue "3000.00"^^xsd:decimal .
</code></pre><p>Let's now identify which instances are the same and which are different among each other.</p>
<p>For example, if I were to add a "SoftwareEng" node, for the same reason of the "Paris-Parigi" example discussed in class, it has to be referred as being the same as SwEng!</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:SoftwareEng a ex:Job ;
    ex:jobTitle "Software Engineer" ;
    ex:jobType "Full-time" ;
    ex:expireDate "2025-02-15"^^xsd:date ;
    ex:belongsTo ex:GueCorp ;
    ex:requires ex:Pitch, ex:SQL ;
    ex:offers ex:HI, ex:TaxBenefit .

ex:SwEng owl:sameAs ex:SoftwareEng .
</code></pre><p>Regarding the "differentFrom" constraint, since we have already defined that our classes are distinct from each other using the "disjointWith" constraint, this information is implicitly inferred. Therefore, we only need to specify that nodes within the same class are distinct from one another:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ex:Pitch owl:differentFrom ex:SQL .
ex:HI owl:differentFrom ex:TaxBenefit .
</code></pre><h3 id="sparql-queries">SPARQL queries </h3>
<ol start="6">
<li>Specify in SPARQL at least 3 queries to be executed over the defined RDF dataset. The requests should:<br>
a. be structurally different (i.e., each of them should contain different constructs)<br>
b. include at least one CONSTRUCT query<br>
c. refer as much as possible to the requests included in the workload specified in PART II.</li>
</ol>
<p>For the <strong>first</strong> query we refer to our Query #1 and we decide to translate it in SPARQL paying attention on how to filter the date attribute:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT ?jobTitle
WHERE {
  ?job a ex:Job ;
       ex:jobType "Full-time" ;
       ex:expireDate ?expireDate ;
       ex:jobTitle ?jobTitle .
  FILTER (xsd:date(?expireDate) &lt;= xsd:date(NOW()) + "P30D"^^xsd:duration)
}
</code></pre><p>For the <strong>second</strong> query we refer to our Query #4 so that we can introduce the DISTINCT construct (differently from the previous query we're returning non-unique values):</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT DISTINCT ?jobType
WHERE {
  ?company ex:operatesIn ?industry ;
           ex:belongsTo ?job .
  ?industry a ex:IndustryDomain ;
            ex:industryName "Technology" .
  ?job ex:jobType ?jobType .
}
</code></pre><p>For the <strong>third</strong> query we want to use (as the assignment requires) the CONSTRUCT keyword:</p>
<p>Construct a graph with all jobs that require skills with a level of Beginner.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>CONSTRUCT {
  ?job a ex:Job ;
       ex:requires ?skill .
}
WHERE {
  ?job a ex:Job ;
       ex:requires ?skill .
  ?skill ex:skillLevel "Beginner" .
}
</code></pre><p>We note that this redundancy inside both CONSTRUCT and WHERE constructs is actually a feature of SPARQL, which allows the user to specify different conditions with respect to the final graph that will be indeed produced!</p>
<p>For a <strong>fourth</strong> query we try to specify a query that involves both OPTIONAL and UNION clauses:</p>
<p>Retrieve jobs with their associated skills, if available, where jobs either belong to companies in Italy OR operate in the Technology industry.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>SELECT ?jobTitle ?skillName
WHERE {
  {
    {
      ?job a ex:Job ;
           ex:belongsTo ?company ;
           ex:jobTitle ?jobTitle .
      ?company ex:country "Italy" .
    }
    UNION
    {
      ?job a ex:Job ;
           ex:belongsTo ?company ;
           ex:jobTitle ?jobTitle .
      ?company ex:operatesIn ?industry .
      ?industry ex:industryName "Technology" .
    }
  }
  
  OPTIONAL {
    ?job ex:requires ?skill .
    ?skill ex:skillName ?skillName .
  }
}
</code></pre><p>We end with a <strong>fifth</strong> query to also cover the "ASK" construct:</p>
<p>Check if any job requires a skill with a level of Beginner.</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code>ASK {
  ?job a ex:Job ;
       ex:requires ?skill .
  ?skill ex:skillLevel "Beginner" .
}
</code></pre><h3 id="lets-try-14-16-content-in-rdf-playground">Let's try 14-16 content in RDF playground! </h3>
<ol start="17">
<li>Check the correctness of the proposed RDF dataset, extended with RDFS /OWL constraints, and of the proposed SPARQL queries using RDF playground (<a href="http://rdfplayground.dcc.uchile.cl/">http://rdfplayground.dcc.uchile.cl/</a>) or any other RDF data store at your choice.</li>
</ol>
<p><strong>We "played" into the "play"ground</strong> and verified the correctness of all classes, properties, constraints and SPARQL queries.<br>
For obtaining a more meaningful and enriched graph we also added some other instances. You can find the whole dataset at this link: (<a href="https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/SPARQL-data-and-queries.ttl">https://raw.githubusercontent.com/enriicola/Linked-adm-In/refs/heads/main/SPARQL-data-and-queries.ttl</a>)</p>
<p><img src="https://github.com/user-attachments/assets/0d5a7ed7-f37c-46df-b53c-b029cbcd0164" alt="SPARQL-graph"></p>
<p>Below, for reference, there are results of the queries for the above dataset:</p>
<pre data-role="codeBlock" data-info="" class="language-text"><code># --- 1 ---
--------------------
| jobTitle         |
====================
| "Data Scientist" |
--------------------

# --- 2 ---
-----------
| jobType |
===========
-----------

# --- 3 ---
(graph
  (triple ex:InternDev ex:requires ex:HTML)
  (triple ex:InternDev ex:requires ex:CSS)
  (triple ex:InternDev rdf:type ex:Job)
)

# --- 4 ---
------------------------------------------
| jobTitle            | skillName        |
==========================================
| "Developer Intern"  | "CSS"            |
| "Developer Intern"  | "HTML"           |
| "Software Engineer" | "SQL"            |
| "Software Engineer" | "Elevator Pitch" |
| "Software Engineer" | "Elevator Pitch" |
| "Software Engineer" | "SQL"            |
| "Developer Intern"  | "CSS"            |
| "Developer Intern"  | "HTML"           |
| "Data Scientist"    | "SQL"            |
| "Data Scientist"    | "Python"         |
------------------------------------------

# --- 5 ---
yes
</code></pre><h3 id="presentation-link-">Presentation Link ðŸ˜ƒ </h3>
<p><a href="https://docs.google.com/presentation/d/10JpM2nPsat2lPP40ubgr755MYcMWq2DNsRzwk-B55IA/edit?usp=sharing">https://docs.google.com/presentation/d/10JpM2nPsat2lPP40ubgr755MYcMWq2DNsRzwk-B55IA/edit?usp=sharing</a></p>
      </div>
    </body></html>